

pos_1_LEFT_UP = posx(196.42, -61.65, 38.82, 156.57, -178.87, 150.08)
pos_1_LEFT_DOWN = posx(206.5, -163.96, 38.31, 127.41, -178.77, 121.08)
pos_1_RIGHT_UP = posx(297.92, -51.09, 38.21, 131.14, -178.96, 124.32)
pos_1_RIGHT_DOWN = posx(308.1, -153.93, 38.48, 108.29, -178.96, 101.89)


# Z축으로 200mm 위에서 접근/후퇴하기 위한 상대 좌표
pos_APPROACH_OFFSET = posx(0, 0, 100, 0, 0, 0)

direction = 0
row = 3
column = 3
stack = 1
thickness = 0
point_offset = [0,0,0]

total_count = row * column * stack


set_digital_output(1,ON)
set_digital_output(2,OFF)
# movej(posj([0 , 0 , 90 , 0 , 90 , 0]))
# --- 메인 루프 (이동 코드 추가) ---
i = 0

while True:
    if i >=9:
        break
    # 1. 팔레트 위치 계산
    # (변수명은 지난번에 얘기한 대로 바꿔서 적용했어!)
    Pallet_Pose1 = get_pattern_point(pos_1_LEFT_UP, pos_1_RIGHT_UP, pos_1_LEFT_DOWN, pos_1_RIGHT_DOWN, i, direction, row, column, stack, thickness, point_offset) 
  
    # 2. 접근 위치 계산 (Pallet_Pose의 200mm 위)
    Approach_Pose1 = trans(Pallet_Pose1, pos_APPROACH_OFFSET, ref=DR_BASE)
    
    # tp_popup("인덱스 {}번 위치로 이동합니다.".format(pallet_index))

    # 3. 로봇 이동
    movel(Approach_Pose1, vel=150, acc=300)
          # a. 접근 위치로 이동
    movel(Pallet_Pose1, vel=100, acc=200)
    wait(0.2)
    x = get_current_posx()
    tp_log(str(x))
    # tp_log(sol)
    movel(Approach_Pose1, vel=150, acc=300)
             # b. 최종 목적지로 이동
    i +=1
